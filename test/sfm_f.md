# sfm的过程

[toc]
对于一个时间窗口内帧的数据做整体处理，对每一帧处理特征点，并确认所有帧之间的特征共视点

- 筛选窗内的特殊的帧，找到一个特征点多的点，然后作为第l帧
- 第ｌ帧和最后一帧之间进行对极化和三角约束，得到姿态和对应特征点的三维位置，注意获得得是第一帧坐标系下的三维位置．？，但是按照他这个方法应该得用转到全局坐标系下的全局特征点．
- 建立一个数据结构存储所有特征点，在每一帧的观察位置
- 逐帧和最后一帧进行pnp,直接使用第N帧和最后一帧的共视点，共视点使用最后一帧的，因为已经将最后一帧的特征点三维位置给出，这样就形成了2d3d的问题，可以算出每一帧相对于最后一帧的姿态，同时吧这两者之间的共视点的坐标修正出来，**但是我还没确定同一个共视点的两次修正是否是完全一样的?**
- 逐帧将[l+1,frame_num]帧与第l帧之间直接进行三角化，因为此时共视点的位置已经给出，对应特征点的位置早已给出．**他这个三角化的函数和以前的不一样，得研究一下，不是直接使用cv给出的，特别关注上面的问题，同一个特征点的多次修正有没有机制**
- 重复上述的过程，即对于从［０，l］之间的帧也执行这个过程．执行特征点的三角化．
- 执行对于所有点的三角化
- ceres全优化这个过程．
**另一个问题是注意使用时特征点的坐标系，是归一化，还是在某一帧的坐标系**

## 1. 特征点的检测和选择

特征点的部分可以使用orb的特征点，但是这样就需要不断对两帧之间的特征点做匹配，以及对任何两帧之间做匹配．然而使用lk光流法，则很快速的避免了这个问题以及随之带来的误匹配问题，lk方法只是会面临环境特殊变化的丢帧问题．

特征点的第二个问题是进入待选共视点的那些点，原来方案给的是根据窗内不同帧对于同一个特征点观测的次数的统计

## 2.三角化函数

一共有两个三角化函数
$triangulateTwoFrames(帧号，姿态，帧号２，姿态，全部可视点)$
$triangulatePoint(姿态，姿态，特征点，特征点，三维点)$